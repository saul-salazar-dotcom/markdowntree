<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MarkdownTree.com - Markdown Editor WebApp with Presentations support</title>
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiTWFya2Rvd25UcmVlIiwic2hvcnRfbmFtZSI6Ik1hcmtkb3duVHJlZSIsImRlc2NyaXB0aW9uIjoiTWFya2Rvd24gbm90ZS10YWtpbmcgYXBwIiwic3RhcnRfdXJsIjoiLyIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiMxODE4MTgiLCJ0aGVtZV9jb2xvciI6IiMwMDc4ZDQiLCJpY29ucyI6W3sic3JjIjoiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQTJOQ0EyTkNJK1BISmxZM1FnZUQwaU5DSWdlVDBpTkNJZ2QybGtkR2c5SWpVMklpQm9aV2xuYUhROUlqVTJJaUJ5ZUQwaU9DSWdabWxzYkQwaUkyVTRaVEJqT0NJZ2IzQmhZMmwwZVQwaUxqZzFJaTgrUEhCaGRHZ2dabWxzYkQwaUl6VmxNMkV4WlNJZ1pEMGlUVEk0SURReWFEaDJNVFJvTFRoNklpOCtQSEJoZEdnZ1ptbHNiRDBpSXpoaU5XRXlZaUlnWkQwaVRUSTRJRFF5YURoMk1tZ3RPSG9pTHo0OGNHRjBhQ0JrUFNKdE1UUWdORElnTVRndE16QWdNVGdnTXpCYUlpQm1hV3hzUFNJak1tRTFZVEpoSWk4K1BIQmhkR2dnWkQwaWJURTRJRE00SURFMExURTRJREUwSURFNFdpSWdabWxzYkQwaUl6TmhOMkV6WVNJdlBqeHdZWFJvSUdROUlrMHhPQ0F6TWlBek1pQTRiREUwSURJMFdpSWdabWxzYkQwaUl6SmhOV0V5WVNJdlBqeHdZWFJvSUdROUltMHlNaUF5T0NBeE1DMHhOQ0F4TUNBeE5Gb2lJR1pwYkd3OUlpTXpZVGRoTTJFaUx6NDhjR0YwYUNCa1BTSk5NaklnTWpJZ016SWdObXd4TUNBeE5sb2lJR1pwYkd3OUlpTXlZVFZoTW1FaUx6NDhjR0YwYUNCa1BTSnRNallnTWpBZ05pMDRJRFlnT0ZvaUlHWnBiR3c5SWlNellUZGhNMkVpTHo0OGNtVmpkQ0I0UFNJMElpQjVQU0kwSWlCM2FXUjBhRDBpTlRZaUlHaGxhV2RvZEQwaU5UWWlJSEo0UFNJNElpQm1hV3hzUFNKdWIyNWxJaUJ6ZEhKdmEyVTlJaU16WVRkaE0yRWlMejQ4TDNOMlp6ND0iLCJ0eXBlIjoiaW1hZ2Uvc3ZnK3htbCIsInNpemVzIjoiYW55In1dfQ==">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHJlY3QgeD0iNCIgeT0iNCIgd2lkdGg9IjU2IiBoZWlnaHQ9IjU2IiByeD0iOCIgZmlsbD0iI2U4ZTBjOCIgb3BhY2l0eT0iLjg1Ii8+PHBhdGggZmlsbD0iIzVlM2ExZSIgZD0iTTI4IDQyaDh2MTRoLTh6Ii8+PHBhdGggZmlsbD0iIzhiNWEyYiIgZD0iTTI4IDQyaDh2MmgtOHoiLz48cGF0aCBkPSJtMTQgNDIgMTgtMzAgMTggMzBaIiBmaWxsPSIjMmE1YTJhIi8+PHBhdGggZD0ibTE4IDM4IDE0LTE4IDE0IDE4WiIgZmlsbD0iIzNhN2EzYSIvPjxwYXRoIGQ9Ik0xOCAzMiAzMiA4bDE0IDI0WiIgZmlsbD0iIzJhNWEyYSIvPjxwYXRoIGQ9Im0yMiAyOCAxMC0xNCAxMCAxNFoiIGZpbGw9IiMzYTdhM2EiLz48cGF0aCBkPSJNMjIgMjIgMzIgNmwxMCAxNloiIGZpbGw9IiMyYTVhMmEiLz48cGF0aCBkPSJtMjYgMjAgNi04IDYgOFoiIGZpbGw9IiMzYTdhM2EiLz48cmVjdCB4PSI0IiB5PSI0IiB3aWR0aD0iNTYiIGhlaWdodD0iNTYiIHJ4PSI4IiBmaWxsPSJub25lIiBzdHJva2U9IiMzYTdhM2EiLz48L3N2Zz4=">
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/3.2.4/dexie.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/5.1.1/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.4/mermaid.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/remark/14.0.2/remark.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 250px;
            background: #252526;
            border-right: 1px solid #3e3e42;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 10px 16px;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: #cccccc;
        }

        .file-tree {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
        }

        .file-item {
            padding: 6px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            font-size: 13px;
            color: #cccccc;
            position: relative;
            user-select: none;
        }

        .file-item:hover {
            background: #2a2d2e;
        }

        .file-item.active {
            background: #094771 !important;
            color: #ffffff !important;
        }

        .file-item.drag-over {
            background: #0e639c;
            border-left: 3px solid #0078d4;
        }

        .file-item.dragging {
            opacity: 0.5;
        }

        .folder-item {
            font-weight: 600;
        }

        .folder-item.collapsed .folder-contents {
            display: none;
        }

        .folder-item .folder-toggle {
            margin-right: 4px;
            font-size: 10px;
            width: 12px;
            text-align: center;
        }

        .folder-contents {
            margin-left: 16px;
        }

        .context-menu {
            position: fixed;
            background: #2d2d30;
            border: 1px solid #5a5a5a;
            border-radius: 4px;
            padding: 4px 0;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .context-menu-item {
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            color: #cccccc;
        }

        .context-menu-item:hover {
            background: #094771;
        }

        .file-icon {
            margin-right: 8px;
            font-size: 16px;
        }

        .file-item {
            display: flex;
            align-items: center;
            padding-right: 8px; /* optional spacing */
        }

        .file-title {
            flex: 1;
            text-align: left;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .file-action {
            margin-left: 8px;
            opacity: 0.5;
            cursor: pointer;
        }

        .file-action:hover {
            opacity: 1;
            color: #e06c75;
        }


        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .tab-bar {
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            min-height: 35px;
            overflow-x: auto;
            max-width: 100vw;
        }

        .tab {
            display: flex;
            align-items: center;
            padding: 0 12px;
            background: #2d2d30;
            border-right: 1px solid #3e3e42;
            cursor: pointer;
            font-size: 13px;
            color: #969696;
            min-width: 120px;
            position: relative;
        }

        .tab.active {
            background: #1e1e1e;
            color: #ffffff;
            border-bottom: 2px solid #0078d4;
        }

        .tab-close {
            margin-left: auto;
            cursor: pointer;
            opacity: 0.5;
        }

        .tab-close:hover {
            opacity: 1;
        }

        .editor-container {
            flex: 1;
            display: flex;
            position: relative;
        }

        .editor-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #3e3e42;
        }

        .editor-pane:last-child {
            border-right: none;
        }

        .editor-toolbar {
            background: #2d2d30;
            padding: 8px 12px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            gap: 8px;
            align-items: center;
            overflow-x: auto;       /* ‚úÖ enable horizontal scroll */
            white-space: nowrap;    /* ‚úÖ prevent buttons from wrapping */
            -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
            max-width: 100vw;
        }

        .editor-toolbar::-webkit-scrollbar {
            height: 6px;
        }

        .editor-toolbar::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }

        .editor-container {
            flex: 1;
            display: flex;
            position: relative;

            flex-direction: column;       /* üì± stack vertically on mobile */
            overflow-y: auto;             /* ‚úÖ allow vertical scrolling */
        }

        @media (min-width: 768px) {
            .editor-container {
                flex-direction: row;      /* üñ•Ô∏è side-by-side on desktop */
            }
        }

        .toolbar-btn {
            padding: 4px 8px;
            background: #3c3c3c;
            border: 1px solid #5a5a5a;
            color: #cccccc;
            cursor: pointer;
            border-radius: 3px;
            font-size: 11px;
        }

        .toolbar-btn.active {
            background: #0078d4;
            border-color: #0078d4;
            color: white;
        }

        .editor {
            flex: 1;
            background: #1e1e1e;
            color: #d4d4d4;
            border: none;
            padding: 20px;
            font-family: 'Consolas', 'Monaco', 'Lucida Console', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            outline: none;
        }

        .preview {
            flex: 1;
            background: #1e1e1e;
            padding: 20px;
            overflow-y: auto;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        .preview a {
            color: #4FC1FF;            /* Light blue */
            text-decoration: underline;
            transition: color 0.2s ease;
        }

        .preview a:hover {
            color: #80E0FF;            /* Brighter on hover */
            text-decoration: underline;
        }

        .preview h1 { color: #ffffff; margin: 0 0 16px 0; }
        .preview h2 { color: #ffffff; margin: 16px 0 12px 0; }
        .preview h3 { color: #ffffff; margin: 12px 0 8px 0; }
        .preview p { margin: 0 0 12px 0; line-height: 1.6; }
        .preview ul, .preview ol { margin: 0 0 12px 20px; }
        .preview li { margin: 4px 0; }
        .preview code { background: #2d2d30; padding: 2px 4px; border-radius: 3px; }
        .preview pre { background: #2d2d30; padding: 12px; border-radius: 6px; overflow-x: auto; }
        .preview blockquote { border-left: 4px solid #0078d4; padding-left: 12px; margin: 12px 0; color: #b4b4b4; }

        .floating-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2d2d30;
            border: 1px solid #5a5a5a;
            border-radius: 6px;
            padding: 20px;
            min-width: 400px;
            z-index: 1000;
        }

        .panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        .btn {
            padding: 8px 16px;
            background: #0078d4;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin: 4px;
        }

        .btn:hover {
            background: #106ebe;
        }

        .btn-secondary {
            background: #3c3c3c;
            border: 1px solid #5a5a5a;
        }

        .btn-secondary:hover {
            background: #4a4a4a;
        }

        .input {
            padding: 8px 12px;
            background: #3c3c3c;
            border: 1px solid #5a5a5a;
            color: #d4d4d4;
            border-radius: 3px;
            width: 100%;
            margin: 4px 0;
        }

        .store-icons {
            display: flex;
            gap: 20px;
            align-items: center;
            margin: 20px 0;
        }

        .store-item {
            text-align: center;
            opacity: 0.5;
        }

        .store-icon {
            width: 40px;
            height: 40px;
            margin-bottom: 8px;
        }

        .hidden { display: none !important; }

        .outline {
            flex: 1;
            padding: 8px 0;
            overflow-y: auto;
        }

        .outline-item {
            padding: 4px 16px;
            cursor: pointer;
            font-size: 12px;
            color: #969696;
        }

        .outline-item:hover {
            background: #2a2d2e;
        }

        .outline-item.h1 { font-weight: bold; color: #ffffff; }
        .outline-item.h2 { margin-left: 8px; color: #cccccc; }
        .outline-item.h3 { margin-left: 16px; color: #969696; }

        .presentation-view {
            background: #000;
            color: #fff;
            padding: 40px;
            font-size: 18px;
            text-align: center;
        }

        .slide {
            max-width: 800px;
            margin: 0 auto;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .slide h1 { font-size: 2.5em; margin-bottom: 0.5em; }
        .slide h2 { font-size: 2em; margin-bottom: 0.5em; }
        .slide p { font-size: 1.2em; line-height: 1.6; }

        .presentation-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .mermaid-container {
            background: white;
            padding: 20px;
            border-radius: 6px;
            margin: 12px 0;
        }

        .settings-view {
            padding: 20px;
            max-width: 600px;
        }

        .setting-group {
            margin-bottom: 24px;
        }

        .setting-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .checkbox {
            margin-right: 8px;
        }

        .sidebar-buttons button {
            padding: 2px 6px;
            font-size: 13px;
        }

        /* Default: show sidebar */
        .sidebar {
        width: 250px;
        flex-shrink: 0;
        transition: transform 0.3s ease;
        }

        /* Hide sidebar off-screen on small screens */
        .sidebar.hidden-mobile {
        transform: translateX(-100%);
        position: absolute;
        z-index: 100;
        height: 100%;
        background: #252526;
        }

        /* Show hamburger only on small screens */
        #toggleSidebarBtn {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            padding: 8px 14px;
            cursor: pointer;
        }

        @media (max-width: 768px) {

            .sidebar {
                position: absolute;
                z-index: 100;
                height: 100%;
            }

            #toggleSidebarBtn {
                display: inline-block;
            }

            .main-content {
                flex: 1;
                margin-left: 0;
            }
        }

    </style>
</head>
<body>
    <div class="app-container">
        <div class="sidebar">
            <div class="sidebar-header">
                <div style="font-weight: bold;font-size: 14px;">MARKDOWNTREE.COM</div>
                <div style="float: left;" class="sidebar-buttons">
                    <button class="btn" onclick="createNewFolder()" title="Create New Folder">üìÅ</button>
                    <button class="btn" onclick="createNewNote()" title="Create New File">üìÑ</button>
                    <button class="btn" onclick="collapseAllFolders()" title="Collapse All">‚ñ≤</button>
                    <button class="btn" onclick="expandAllFolders()" title="Expand All">‚ñº</button>
                    <button class="btn" onclick="openSourceCode()" title="Source Code">
                        <svg height="14" width="14" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
  <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 
           2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 
           0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52
           -.01-.53.63-.01 1.08.58 1.23.82.72 1.21 
           1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 
           0-.87.31-1.59.82-2.15-.08-.2-.36-1.01.08-2.11 
           0 0 .67-.21 2.2.82a7.65 7.65 0 0 1 2-.27c.68 0 
           1.36.09 2 .27 1.53-1.04 2.2-.82 
           2.2-.82.44 1.1.16 1.91.08 2.11.51.56.82 
           1.27.82 2.15 0 3.07-1.87 
           3.75-3.65 3.95.29.25.54.73.54 1.48 
           0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 
           8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
</svg>
                    </button>
                </div>
            </div>
            <div class="file-tree" id="fileTree"></div>
            <div class="sidebar-header">üìã Outline</div>
            <div class="outline" id="outline"></div>
        </div>

        <div class="main-content">
            <div class="tab-bar" id="tabBar">
            </div>
            <div class="editor-toolbar">
                <button class="toolbar-btn active" onclick="setViewMode('text')" id="btn-text">Text</button>
                <button class="toolbar-btn" onclick="setViewMode('preview')" id="btn-preview">Preview</button>
                <button class="toolbar-btn" onclick="setViewMode('split')" id="btn-split">Split</button>
                <button class="toolbar-btn" onclick="startPresentation()">üé¨ Present</button>
                <button class="toolbar-btn" onclick="showInstallPanel()">üì± Install</button>
                <button class="toolbar-btn" onclick="importNotes()">üì• Import</button>
                <button class="toolbar-btn" onclick="exportNotes()">üì§ Export</button>
                <button class="toolbar-btn" onclick="showSettings()">‚öôÔ∏è Settings</button>
            </div>
            <div class="editor-container" id="editorContainer">
                <div class="editor-pane">
                    <textarea class="editor" id="editor" placeholder="Start typing your note..."></textarea>
                </div>
            </div>
        </div>
    </div>

    <!-- Install Panel -->
    <div class="panel-overlay hidden" id="installOverlay" onclick="hideInstallPanel()"></div>
    <div class="floating-panel hidden" id="installPanel">
        <h2>Install App</h2>
        <p>Install directly from the web or get notified when mobile apps are available.</p>
        
        <button class="btn" onclick="installPWA()" id="installBtn">üåê Install Web App</button>
        
        <div class="store-icons">
            <div class="store-item">
                <svg class="store-icon" viewBox="0 0 24 24" fill="#a0a0a0">
                    <path d="M17.05 20.28c-.98.95-2.05.8-3.08.35-1.09-.46-2.09-.48-3.24 0-1.44.62-2.2.44-3.06-.35C2.79 15.25 3.51 7.59 9.05 7.31c1.35.07 2.29.74 3.08.8 1.18-.24 2.31-.93 3.57-.84 1.51.12 2.65.72 3.4 1.8-3.12 1.87-2.38 5.98.48 7.13-.57 1.5-1.31 2.99-2.54 4.09l.01-.01zM12.03 7.25c-.15-2.23 1.66-4.07 3.74-4.25.29 2.58-2.34 4.5-3.74 4.25z"/>
                </svg>
                <div style="font-size: 12px;">App Store<br>Coming Soon</div>
            </div>
            <div class="store-item">
                <svg class="store-icon" viewBox="0 0 24 24" fill="#a0a0a0">
                    <path d="M3,20.5V3.5C3,2.91 3.34,2.39 3.84,2.15L13.69,12L3.84,21.85C3.34,21.61 3,21.09 3,20.5M16.81,15.12L6.05,21.34L14.54,12.85L16.81,15.12M20.16,10.81C20.5,11.08 20.75,11.5 20.75,12C20.75,12.5 20.53,12.9 20.18,13.18L17.89,14.5L15.39,12L17.89,9.5L20.16,10.81M6.05,2.66L16.81,8.88L14.54,11.15L6.05,2.66Z"/>
                </svg>
                <div style="font-size: 12px;">Google Play<br>Coming Soon</div>
            </div>
        </div>
        
        <button class="btn btn-secondary" onclick="hideInstallPanel()">Close</button>
    </div>

    <!-- Settings Panel -->
    <div class="panel-overlay hidden" id="settingsOverlay" onclick="hideSettings()"></div>
    <div class="floating-panel hidden" id="settingsPanel">
        <div class="settings-view">
            <h2>Settings</h2>
            
            <div class="setting-group">
                <label class="setting-label">
                    <input type="checkbox" class="checkbox" id="htmlSupport"> Enable HTML Support
                </label>
                <small style="color: #969696;">Allow HTML tags in markdown rendering</small>
            </div>
            
            <div class="setting-group">
                <label class="setting-label">Plugins</label>
                <label style="display: block; margin: 8px 0;">
                    <input type="checkbox" class="checkbox" id="mermaidPlugin" checked> Mermaid Diagrams
                </label>
                <label style="display: block; margin: 8px 0;">
                    <input type="checkbox" class="checkbox" id="presentationPlugin" checked> Presentation Mode
                </label>
            </div>
            
            <div style="margin-top: 20px;">
                <button class="btn" onclick="saveSettings()">Save Settings</button>
                <button class="btn btn-secondary" onclick="hideSettings()">Cancel</button>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept=".md,.zip" style="display: none;" onchange="handleFileImport()">

    <script>
        // Database setup
        const db = new Dexie('NotesDB');
        db.version(1).stores({
            notes: '++id, title, content, metadata, created, modified',
            settings: 'key, value'
        });
        db.version(2).stores({
            notes: '++id, title, content, metadata, created, modified, folder',
            settings: 'key, value',
            folders: '++id, name, parent'
        });

        // App state
        let currentNotes = [];
        let currentNote = null;
        let currentView = 'text';
        let openTabs = [];
        let activeTab = null;
        let folders = [];
        let collapsedFolders = new Set();
        let contextMenu = null;
        let settings = {
            htmlSupport: false,
            mermaidPlugin: true,
            presentationPlugin: true
        };
        let selectedFolderId = null;

        // Plugin system
        const plugins = {
            mermaid: {
                name: 'Mermaid Diagrams',
                enabled: true,
                process: (content) => {
                    if (!settings.mermaidPlugin) return content;
                    return content.replace(/```mermaid\n([\s\S]*?)\n```/g, (match, diagram) => {
                        const id = 'mermaid-' + Math.random().toString(36).substr(2, 9);
                        setTimeout(() => {
                            try {
                                mermaid.render(id, diagram).then(result => {
                                    const element = document.getElementById(id);
                                    if (element) {
                                        element.innerHTML = result.svg;
                                    }
                                });
                            } catch (e) {
                                console.error('Mermaid rendering error:', e);
                            }
                        }, 100);
                        return `<div class="mermaid-container"><div id="${id}">Loading diagram...</div></div>`;
                    });
                }
            },
            presentation: {
                name: 'Presentation Mode',
                enabled: true,
                process: (content) => {
                    if (!settings.presentationPlugin) return content;
                    return content;
                }
            }
        };

        // Service Worker registration
        if ('serviceWorker' in navigator) {
            const swCode = `
                const CACHE_NAME = 'notes-pwa-v1';
                const urlsToCache = ['/'];
                
                self.addEventListener('install', event => {
                    event.waitUntil(
                        caches.open(CACHE_NAME)
                            .then(cache => cache.addAll(urlsToCache))
                    );
                });
                
                self.addEventListener('fetch', event => {
                    event.respondWith(
                        caches.match(event.request)
                            .then(response => response || fetch(event.request))
                    );
                });
            `;
            
            const blob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(blob);
            
            navigator.serviceWorker.register(swUrl);
        }

        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            sidebar.classList.toggle('hidden-mobile');
        }

        function openSourceCode() {
            window.open('https://github.com/saul-salazar-dotcom/markdowntree', '_blank', 'noopener,noreferrer');
        }

        // Initialize app
        async function initApp() {
            await loadSettings();
            await loadNotes();
            
            if (currentNotes.length === 0) {
                await createWelcomeNote();
                await loadNotes(); // Reload after creating welcome note
            }

            openNote(currentNotes[0]);
            updateFileTree();
            
            // Set up editor event listener
            const editor = document.getElementById('editor');
            if (editor) {
                editor.addEventListener('input', debounce(handleEditorChange, 500));
            }
            
            // Initialize marked with plugins
            marked.setOptions({
                highlight: function(code, lang) {
                    if (Prism.languages[lang]) {
                        return Prism.highlight(code, Prism.languages[lang], lang);
                    }
                    return code;
                }
            });
        }

        async function loadSettings() {
            try {
                const savedSettings = await db.settings.toArray();
                savedSettings.forEach(setting => {
                    settings[setting.key] = setting.value;
                });
            } catch (error) {
                console.error('Error loading settings:', error);
            }
        }

        async function saveSettings() {
            settings.htmlSupport = document.getElementById('htmlSupport').checked;
            settings.mermaidPlugin = document.getElementById('mermaidPlugin').checked;
            settings.presentationPlugin = document.getElementById('presentationPlugin').checked;
            
            try {
                await db.settings.clear();
                for (const [key, value] of Object.entries(settings)) {
                    await db.settings.add({ key, value });
                }
                hideSettings();
                updatePreview();
            } catch (error) {
                console.error('Error saving settings:', error);
            }
        }

        async function loadNotes() {
            try {
                currentNotes = await db.notes.orderBy('modified').reverse().toArray();
                // Only try to load folders if the table exists (version 2+)
                try {
                    folders = await db.folders.toArray();
                } catch (folderError) {
                    console.log('Folders table not available, using empty array');
                    folders = [];
                }
            } catch (error) {
                console.error('Error loading notes:', error);
                currentNotes = [];
                folders = [];
            }
        }

        async function createWelcomeNote() {
            const welcomeContent = `---
title: Welcome
tags: [welcome, guide]
created: ${new Date().toISOString()}
---

# Welcome to MarkDownTree

This is a **Progressive Web App**, you can install it on your device (mobile or desktop) and use it offline.

## Features
- **Markdown Support**: Write in markdown syntax.
- **Syntax Highlight**: Add color to your code snippets.
- **File Tree**: Organize notes into hierarchical folders.
- **Presentations**: Allows to use remarkjs to create and preview presentations.
- **Outline**: Show the headers of the notes in a tree structure for easy navigation.
- **Local First**: All your data is stored locally, it never leaves your device.
- **Large data Support**: Thanks to IndexedDB, you can store large amounts of data.
- **No Vendor Lock-In**: Import/export individual notes or entire collections as \`.md\` files`;

            const note = await saveNote('Welcome to Notes PWA', welcomeContent);

            return note;
        }

        function toggleFolder(folderId) {
            if (collapsedFolders.has(folderId)) {
                collapsedFolders.delete(folderId);
            } else {
                collapsedFolders.add(folderId);
            }
            updateFileTree();
        }

        function setupDragHandlers(element, type, item) {
            element.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', JSON.stringify({ type, item }));
                element.classList.add('dragging');
            });

            element.addEventListener('dragend', (e) => {
                element.classList.remove('dragging');
                // Remove drag-over class from all elements
                document.querySelectorAll('.drag-over').forEach(el => {
                    el.classList.remove('drag-over');
                });
            });

            element.addEventListener('dragover', (e) => {
                e.preventDefault();
                if (type === 'folder') {
                    element.classList.add('drag-over');
                }
            });

            element.addEventListener('dragleave', (e) => {
                element.classList.remove('drag-over');
            });

            element.addEventListener('drop', async (e) => {
                e.preventDefault();
                element.classList.remove('drag-over');
                
                if (type === 'folder') {
                    try {
                        const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
                        if (dragData.type === 'note') {
                            await moveNoteToFolder(dragData.item.id, item.id);
                        }
                    } catch (error) {
                        console.error('Error handling drop:', error);
                    }
                }
            });
        }

        async function moveNoteToFolder(noteId, folderId) {
            try {
                const note = currentNotes.find(n => n.id === noteId);
                if (!note) return;

                note.folder = folderId;
                note.modified = new Date().toISOString();
                
                await db.notes.put(note);
                
                // Update currentNotes array
                const index = currentNotes.findIndex(n => n.id === noteId);
                if (index !== -1) {
                    currentNotes[index] = note;
                }
                
                // Update currentNote if it's the one being moved
                if (currentNote && currentNote.id === noteId) {
                    currentNote = note;
                }
                
                updateFileTree();
            } catch (error) {
                console.error('Error moving note to folder:', error);
            }
        }

        function showContextMenu(e, type, item) {
            hideContextMenu();
            
            contextMenu = document.createElement('div');
            contextMenu.className = 'context-menu';
            contextMenu.style.left = e.pageX + 'px';
            contextMenu.style.top = e.pageY + 'px';
            
            if (type === 'note') {
                contextMenu.innerHTML = `
                    <div class="context-menu-item" onclick="moveNoteToRoot(${item.id})">Move to Root</div>
                    <div class="context-menu-item" onclick="renameNote(${item.id})">Rename</div>
                    <div class="context-menu-item" onclick="deleteNote(${item.id})">Delete</div>
                `;
            } else if (type === 'folder') {
                contextMenu.innerHTML = `
                    <div class="context-menu-item" onclick="renameFolder(${item.id})">Rename Folder</div>
                    <div class="context-menu-item" onclick="deleteFolder(${item.id})">Delete Folder</div>
                `;
            }
            
            document.body.appendChild(contextMenu);
            
            // Hide context menu when clicking elsewhere
            setTimeout(() => {
                document.addEventListener('click', hideContextMenu, { once: true });
            }, 0);
        }

        function hideContextMenu() {
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
            }
        }

        async function moveNoteToRoot(noteId) {
            await moveNoteToFolder(noteId, null);
            hideContextMenu();
        }

        async function renameNote(noteId) {
            const note = currentNotes.find(n => n.id === noteId);
            if (!note) return;
            
            const newTitle = prompt('Enter new title:', note.title);
            if (!newTitle || newTitle === note.title) return;
            
            note.title = newTitle;
            note.modified = new Date().toISOString();
            
            // Update frontmatter if it exists
            if (note.content.startsWith('---')) {
                const lines = note.content.split('\n');
                let inFrontmatter = false;
                let frontmatterEnd = -1;
                
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i] === '---') {
                        if (!inFrontmatter) {
                            inFrontmatter = true;
                        } else {
                            frontmatterEnd = i;
                            break;
                        }
                    } else if (inFrontmatter && lines[i].startsWith('title:')) {
                        lines[i] = `title: ${newTitle}`;
                    }
                }
                note.content = lines.join('\n');
            }
            
            await db.notes.put(note);
            
            // Update arrays and UI
            const index = currentNotes.findIndex(n => n.id === noteId);
            if (index !== -1) {
                currentNotes[index] = note;
            }
            
            if (currentNote && currentNote.id === noteId) {
                currentNote = note;
                document.getElementById('editor').value = note.content;
            }
            
            // Update tab title
            const tabIndex = openTabs.findIndex(t => t.id === noteId);
            if (tabIndex !== -1) {
                openTabs[tabIndex].title = newTitle;
                updateTabs();
            }
            
            updateFileTree();
            hideContextMenu();
        }

        async function deleteNote(noteId) {
            if (!confirm('Are you sure you want to delete this note?')) return;
            
            try {
                await db.notes.delete(noteId);
                currentNotes = currentNotes.filter(n => n.id !== noteId);
                
                // Close tab if open
                closeTab(noteId);
                
                // Clear current note if it was the deleted one
                if (currentNote && currentNote.id === noteId) {
                    currentNote = null;
                    document.getElementById('editor').value = '';
                    updatePreview();
                    updateOutline();
                }
                
                updateFileTree();
            } catch (error) {
                console.error('Error deleting note:', error);
            }
            
            hideContextMenu();
        }

        async function renameFolder(folderId) {
            const folder = folders.find(f => f.id === folderId);
            if (!folder) return;
            
            const newName = prompt('Enter new folder name:', folder.name);
            if (!newName || newName === folder.name) return;
            
            folder.name = newName;
            
            try {
                await db.folders.put(folder);
                const index = folders.findIndex(f => f.id === folderId);
                if (index !== -1) {
                    folders[index] = folder;
                }
                updateFileTree();
            } catch (error) {
                console.error('Error renaming folder:', error);
            }
            
            hideContextMenu();
        }

        async function deleteFolder(folderId) {
            if (!confirm('Are you sure you want to delete this folder? Notes will be moved to root.')) return;
            
            try {
                // Move all notes in this folder to root
                const folderNotes = currentNotes.filter(n => n.folder === folderId);
                for (const note of folderNotes) {
                    note.folder = null;
                    await db.notes.put(note);
                }
                
                // Delete the folder
                await db.folders.delete(folderId);
                folders = folders.filter(f => f.id !== folderId);
                
                // Reload notes to get updated folder assignments
                await loadNotes();
                updateFileTree();
            } catch (error) {
                console.error('Error deleting folder:', error);
            }
            
            hideContextMenu();
        }

        async function createNewNote() {
            const title = prompt('Enter note title:') || `Note ${Date.now()}`;
            const content = `---
title: ${title}
tags: []
created: ${new Date().toISOString()}
---

# ${title}

Start writing your note here...`;
            
            // Save current note first if there's content
            if (currentNote) {
                await handleEditorChange();
            }
            
            const newNote = await saveNote(title, content, true);
            if (newNote) {
                await loadNotes(); // ‚úÖ reload from IndexedDB
                openNote(newNote);
                updateFileTree();
            }
        }

        async function createNewFolder() {
            const name = prompt('Enter folder name:');
            if (!name) return;

            const folder = {
                name,
                parent: selectedFolderId  // new line: set parent to selected
            };

            try {
                const id = await db.folders.add(folder);
                folders.push({ ...folder, id });
                updateFileTree();
            } catch (error) {
                console.error('Error creating folder:', error);
            }
        }


        async function saveNote(title, content, createNew = false) {
            const metadata = extractMetadata(content);
            const note = {
                title,
                content,
                metadata,
                created: metadata.created || new Date().toISOString(),
                modified: new Date().toISOString(),
                folder: null // Default to no folder
            };
            
            try {
                if (currentNote && currentNote.id && !createNew) {
                    note.id = currentNote.id;
                    note.folder = currentNote.folder; // Preserve existing folder
                    await db.notes.put(note);
                    // Update the note in currentNotes array
                    const index = currentNotes.findIndex(n => n.id === note.id);
                    if (index !== -1) {
                        currentNotes[index] = note;
                    }
                    currentNote = note;
                } else {
                    const id = await db.notes.add(note);
                    note.id = id;
                    if (createNew) {
                        // Don't set as current note when creating new from import
                        return note;
                    } else {
                        currentNote = note;
                    }
                }
                
                console.log('Note saved:', note); // Debug log
                console.log('Current notes array:', currentNotes); // Debug log
                
                return note;
            } catch (error) {
                console.error('Error saving note:', error);
            }
        }

        function extractMetadata(content) {
            const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
            if (yamlMatch) {
                try {
                    return jsyaml.load(yamlMatch[1]);
                } catch (error) {
                    console.error('Error parsing YAML:', error);
                }
            }
            return {};
        }

        function openNote(note) {
            // Remove active class from all file items
            document.querySelectorAll('.file-item').forEach(item => {
                item.classList.remove('active');
            });
            
            currentNote = note;
            
            // Add to tabs if not already open
            if (!openTabs.find(tab => tab.id === note.id)) {
                openTabs.push(note);
            }
            
            activeTab = note.id;
            updateTabs();
            
            // Add active class to the clicked file item
            const fileItems = document.querySelectorAll('.file-item');
            fileItems.forEach(item => {
                if (item.dataset.noteId == note.id) {
                    item.classList.add('active');
                }
            });
            
            document.getElementById('editor').value = note.content;
            updatePreview();
            updateOutline();
            if (window.innerWidth <= 768) {
                document.querySelector('.sidebar').classList.add('hidden-mobile');
            }
        }

        function closeTab(noteId) {
            openTabs = openTabs.filter(tab => tab.id !== noteId);
            
            if (activeTab === noteId) {
                activeTab = openTabs.length > 0 ? openTabs[0].id : null;
                if (activeTab) {
                    const note = currentNotes.find(n => n.id === activeTab);
                    if (note) openNote(note);
                } else {
                    document.getElementById('editor').value = '';
                    updatePreview();
                    updateOutline();
                }
            }
            
            updateTabs();
        }

        function updateTabs() {
            const tabBar = document.getElementById('tabBar');
            tabBar.innerHTML = '<button id="toggleSidebarBtn" onclick="toggleSidebar()">‚ò∞</button>';
            
            openTabs.forEach(tab => {
                const tabElement = document.createElement('div');
                tabElement.className = `tab ${activeTab === tab.id ? 'active' : ''}`;
                tabElement.onclick = () => switchTab(tab.id);
                tabElement.innerHTML = `
                    <span>${tab.title}</span>
                    <span class="tab-close" onclick="event.stopPropagation(); closeTab(${tab.id})">√ó</span>
                `;
                tabBar.appendChild(tabElement);
            });
        }

        function switchTab(noteId) {
            const note = currentNotes.find(n => n.id === noteId);
            if (note) {
                openNote(note);
            }
        }

        function renderFolderTree(parentId = null, container = document.getElementById('fileTree')) {
            const childFolders = folders.filter(f => f.parent === parentId);
            const childNotes = currentNotes.filter(n => n.folder === parentId); // ‚úÖ Exact match

            // Folders first
            childFolders.forEach(folder => {
                const isCollapsed = collapsedFolders.has(folder.id);
                const folderItem = document.createElement('div');
                folderItem.className = `file-item folder-item ${isCollapsed ? 'collapsed' : ''}`;
                folderItem.dataset.folderId = folder.id;
                folderItem.draggable = true;
                folderItem.innerHTML = `
                    <span class="folder-toggle">${isCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                    <span class="file-icon">üìÅ</span>
                    <span>${folder.name}</span>
                `;

                folderItem.onclick = (e) => {
                    e.stopPropagation();
                    toggleFolder(folder.id);
                    selectedFolderId = folder.id;
                };

                folderItem.oncontextmenu = (e) => {
                    e.preventDefault();
                    showContextMenu(e, 'folder', folder);
                    selectedFolderId = folder.id;
                };

                setupDragHandlers(folderItem, 'folder', folder);
                container.appendChild(folderItem);

                const folderContents = document.createElement('div');
                folderContents.className = 'folder-contents';

                if (!isCollapsed) {
                    renderFolderTree(folder.id, folderContents); // Recursive call
                }

                container.appendChild(folderContents);
            });

            // Then notes in this level
            childNotes.forEach(note => {
                const fileItem = document.createElement('div');
                fileItem.className = `file-item ${currentNote && currentNote.id === note.id ? 'active' : ''}`;
                fileItem.dataset.noteId = note.id;
                fileItem.draggable = true;
                fileItem.innerHTML = `
                    <span class="file-icon">üìÑ</span>
                    <span class="file-title">${note.title}</span>
                    <span class="file-action" title="Delete" onclick="event.stopPropagation(); renameNote(${note.id})">‚úèÔ∏è</span>
                    <span class="file-action" title="Delete" onclick="event.stopPropagation(); deleteNote(${note.id})">üóëÔ∏è</span>
                `;
                fileItem.onclick = (e) => {
                    e.stopPropagation();
                    openNote(note);
                };
                fileItem.oncontextmenu = (e) => {
                    e.preventDefault();
                    showContextMenu(e, 'note', note);
                    selectedFolderId = parentId;
                };
                setupDragHandlers(fileItem, 'note', note);
                container.appendChild(fileItem);
            });
        }

        function updateFileTree() {
            const fileTree = document.getElementById('fileTree');
            fileTree.innerHTML = '';
            renderFolderTree(null, fileTree); // root-level and nested
        }

        function collapseAllFolders() {
            folders.forEach(folder => {
                collapsedFolders.add(folder.id);
            });
            updateFileTree();
        }

        function expandAllFolders() {
            collapsedFolders.clear();
            updateFileTree();
        }

        function updateOutline() {
            const outline = document.getElementById('outline');
            outline.innerHTML = '';
            
            if (!currentNote) return;
            
            const content = document.getElementById('editor').value;
            const lines = content.split('\n');
            
            lines.forEach((line, index) => {
                const headerMatch = line.match(/^(#{1,6})\s+(.+)/);
                if (headerMatch) {
                    const level = headerMatch[1].length;
                    const text = headerMatch[2];
                    
                    const outlineItem = document.createElement('div');
                    outlineItem.className = `outline-item h${level}`;
                    outlineItem.textContent = text;
                    outlineItem.onclick = () => scrollToLine(index);
                    outline.appendChild(outlineItem);
                }
            });
        }

        function scrollToLine(lineNumber) {
            const editor = document.getElementById('editor');
            const lines = editor.value.split('\n');
            let charCount = 0;
            
            for (let i = 0; i < lineNumber; i++) {
                charCount += lines[i].length + 1; // +1 for newline
            }
            
            editor.setSelectionRange(charCount, charCount);
            editor.focus();
        }

        function setViewMode(mode) {
            currentView = mode;
            
            const container = document.getElementById('editorContainer');
            document.querySelector('.editor-toolbar button.active').classList.toggle('active');
            document.querySelector(`.editor-toolbar #btn-${mode}`).classList.toggle('active');
            if (!container) {
                console.error('Editor container not found');
                return;
            }
            
            if (mode === 'text') {
                container.innerHTML = `
                    <div class="editor-pane">
                        <textarea class="editor" id="editor" placeholder="Start typing your note...">${currentNote ? currentNote.content : ''}</textarea>
                    </div>
                `;
            } else if (mode === 'preview') {
                container.innerHTML = `
                    <div class="editor-pane">
                        <div class="preview" id="preview"></div>
                    </div>
                `;
            } else if (mode === 'split') {
                container.innerHTML = `
                    <div class="editor-pane">
                        <textarea class="editor" id="editor" placeholder="Start typing your note...">${currentNote ? currentNote.content : ''}</textarea>
                    </div>
                    <div class="editor-pane">
                        <div class="preview" id="preview"></div>
                    </div>
                `;
            }
            
            // Re-attach event listener
            const editor = document.getElementById('editor');
            if (editor) {
                editor.addEventListener('input', debounce(handleEditorChange, 500));
            }
            
            updatePreview();
        }

        function updatePreview() {
            const preview = document.getElementById('preview');
            if (!preview) return;
            
            const editor = document.getElementById('editor');
            let content = editor ? editor.value : (currentNote ? currentNote.content : '');
            
            // Remove frontmatter from preview
            content = content.replace(/^---\n[\s\S]*?\n---\n/, '');
            
            // Apply plugins
            Object.values(plugins).forEach(plugin => {
                if (plugin.enabled) {
                    content = plugin.process(content);
                }
            });
            
            // Convert markdown to HTML
            let html = marked.parse(content);
            
            // If HTML support is disabled, escape HTML tags
            if (!settings.htmlSupport) {
                html = html.replace(/<(?!\/?(p|br|strong|em|code|pre|h[1-6]|ul|ol|li|blockquote|a|img)\b)[^>]*>/gi, (match) => {
                    return match.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                });
            }
            
            preview.innerHTML = html;
            
            // Highlight code blocks
            preview.querySelectorAll('pre code').forEach(block => {
                Prism.highlightElement(block);
            });
        }

        async function handleEditorChange() {
            const editor = document.getElementById('editor');
            if (!editor || !currentNote) return;
            
            const content = editor.value;
            const metadata = extractMetadata(content);
            const title = metadata.title || currentNote.title;
            
            // Update current note
            currentNote.content = content;
            currentNote.metadata = metadata;
            currentNote.title = title;
            currentNote.modified = new Date().toISOString();
            
            // Save to database
            try {
                await db.notes.put(currentNote);
                // Update the note in currentNotes array
                const index = currentNotes.findIndex(n => n.id === currentNote.id);
                if (index !== -1) {
                    currentNotes[index] = { ...currentNote };
                }
                // Update tab title if it changed
                const tabIndex = openTabs.findIndex(t => t.id === currentNote.id);
                if (tabIndex !== -1) {
                    openTabs[tabIndex].title = title;
                    updateTabs();
                }
                // Always update file tree to reflect changes
                updateFileTree();
                updatePreview();
                updateOutline();
            } catch (error) {
                console.error('Error saving note:', error);
            }
        }

        function startPresentation() {
            if (!currentNote || !settings.presentationPlugin) return;
            
            const content = document.getElementById('editor').value;
            const slides = content.split(/^---$/gm).map(slide => slide.trim()).filter(slide => slide);
            
            if (slides.length === 0) return;
            
            let currentSlide = 0;
            
            const container = document.getElementById('editorContainer')
            
            container.innerHTML = `
                <div class="presentation-view">
                    <div class="slide" id="currentSlide"></div>
                    <div class="presentation-controls">
                        <button class="btn" onclick="previousSlide()">‚Üê Previous</button>
                        <span id="slideCounter">1 / ${slides.length}</span>
                        <button class="btn" onclick="nextSlide()">Next ‚Üí</button>
                        <button class="btn btn-secondary" onclick="exitPresentation()">Exit</button>
                    </div>
                </div>
            `;
            
            window.presentationSlides = slides;
            window.currentSlideIndex = 0;
            
            showSlide(0);
        }

        function showSlide(index) {
            const slides = window.presentationSlides;
            if (!slides || index < 0 || index >= slides.length) return;
            
            window.currentSlideIndex = index;
            
            const slideElement = document.getElementById('currentSlide');
            const counterElement = document.getElementById('slideCounter');
            
            if (slideElement) {
                // Remove frontmatter and convert markdown
                let content = slides[index].replace(/^---\n[\s\S]*?\n---\n/, '');
                slideElement.innerHTML = marked.parse(content);
            }
            
            if (counterElement) {
                counterElement.textContent = `${index + 1} / ${slides.length}`;
            }
        }

        function nextSlide() {
            showSlide(window.currentSlideIndex + 1);
        }

        function previousSlide() {
            showSlide(window.currentSlideIndex - 1);
        }

        function exitPresentation() {
            setViewMode('split'); // Default back to split view
        }

        async function exportNotes() {
            const format = prompt('Export format:\n1. Individual files (.md)\n2. ZIP archive\n\nEnter 1 or 2:');

            if (format === '1') {
                // Export individual files
                currentNotes.forEach(note => {
                    const blob = new Blob([note.content], { type: 'text/markdown' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${note.title}.md`;
                    a.click();
                    URL.revokeObjectURL(url);
                });
            } else if (format === '2') {
                const zip = new JSZip();

                // Create a lookup for folder names
                const folderMap = {};
                folders.forEach(folder => {
                    folderMap[folder.id] = folder.name;
                });

                // Organize notes into folders or root
                currentNotes.forEach(note => {
                    const filename = `${note.title}.md`;
                    if (note.folder && folderMap[note.folder]) {
                        const folderName = folderMap[note.folder];
                        zip.folder(folderName).file(filename, note.content);
                    } else {
                        zip.file(filename, note.content); // root-level note
                    }
                });

                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'notes-export.zip';
                a.click();
                URL.revokeObjectURL(url);
            }
        }


        function importNotes() {
            document.getElementById('fileInput').click();
        }

        async function handleFileImport() {
            const fileInput = document.getElementById('fileInput');
            const files = fileInput.files;
            
            if (files.length === 0) return;
            
            try {
                let importedNotes = [];
                
                for (const file of files) {
                    if (file.name.endsWith('.md')) {
                        const content = await file.text();
                        const metadata = extractMetadata(content);
                        const title = metadata.title || file.name.replace('.md', '');
                        const newNote = await saveNote(title, content, true); // Create new note
                        if (newNote) {
                            importedNotes.push(newNote);
                        }
                    } else if (file.name.endsWith('.zip')) {
                        const zip = new JSZip();
                        const zipContent = await zip.loadAsync(file);
                        
                        for (const [filename, fileObj] of Object.entries(zipContent.files)) {
                            if (filename.endsWith('.md') && !fileObj.dir) {
                                const content = await fileObj.async('text');
                                const metadata = extractMetadata(content);
                                const title = metadata.title || filename.replace('.md', '');
                                const newNote = await saveNote(title, content, true); // Create new note
                                if (newNote) {
                                    importedNotes.push(newNote);
                                }
                            }
                        }
                    }
                }
                
                fileInput.value = '';
                await loadNotes();        // ‚úÖ reload from DB to refresh currentNotes and folders
                updateFileTree();         // ‚úÖ rebuild UI from fresh data
                
                // Open first imported note if no note is currently open
                if (importedNotes.length > 0 && !currentNote) {
                    openNote(importedNotes[0]);
                }
                
                alert(`Import completed successfully! Imported ${importedNotes.length} note(s).`);
            } catch (error) {
                console.error('Import error:', error);
                alert('Error importing files: ' + error.message);
            }
        }

        function showInstallPanel() {
            document.getElementById('installOverlay').classList.remove('hidden');
            document.getElementById('installPanel').classList.remove('hidden');
        }

        function hideInstallPanel() {
            document.getElementById('installOverlay').classList.add('hidden');
            document.getElementById('installPanel').classList.add('hidden');
        }

        function showSettings() {
            document.getElementById('htmlSupport').checked = settings.htmlSupport;
            document.getElementById('mermaidPlugin').checked = settings.mermaidPlugin;
            document.getElementById('presentationPlugin').checked = settings.presentationPlugin;
            
            document.getElementById('settingsOverlay').classList.remove('hidden');
            document.getElementById('settingsPanel').classList.remove('hidden');
        }

        function hideSettings() {
            document.getElementById('settingsOverlay').classList.add('hidden');
            document.getElementById('settingsPanel').classList.add('hidden');
        }

        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
        });

        function installPWA() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the install prompt');
                    }
                    deferredPrompt = null;
                });
            } else {
                alert('To install this app:\n\n1. Click the install icon in your browser\'s address bar\n2. Or use your browser\'s menu to "Install" or "Add to Home Screen"');
            }
        }

        // Utility functions
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Global key bindings
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'n':
                        e.preventDefault();
                        createNewNote();
                        break;
                    case 's':
                        e.preventDefault();
                        if (currentNote) {
                            handleEditorChange();
                        }
                        break;
                    case 'w':
                        e.preventDefault();
                        if (activeTab) {
                            closeTab(activeTab);
                        }
                        break;
                }
            }
        });

        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', async () => {
            // Then initialize the app
            await initApp();
        });
    </script>
</body>
</html>
